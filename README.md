# Лабораторная работа №5 - **JavaBffService**

## Лабораторная работа считается готовой к сдаче, если выполнены следующие действия:

### 1. Написать файл миграции, который создаст таблицу `user`
- Создать файл миграции с именем, соответствующим соглашениям (например, `create-user-table.sql`).
- Таблица должна содержать следующие поля:
   - `id` (тип: `BIGINT`, первичный ключ).
   - `username` (тип: `VARCHAR`, уникальное, не null).
   - `password` (тип: `VARCHAR`, не null).
- Обеспечить наличие уникального индекса на поле `username`.

### 2. Дописать FeignClient и настроить его на общение с ServiceManagement
- Добавить интерфейс `FeignClient` для взаимодействия с сервисом `ServiceManagement`.
- Конфигурация клиента:
   - Указать базовый URL сервиса в настройках приложения (`application.yml` или `application.properties`).
   - Пример настройки метода, который отправляет запросы на получение данных о пользователях:
     ```java
     @FeignClient(name = "service-management", url = "${service.management.url}")
     public interface ServiceManagementClient {
     
         @GetMapping("/users/{username}")
         UserDto getUserByUsername(@PathVariable("username") String username);
     }
     ```

### 3. Доделать реализацию Spring Security с классической формой
- Настроить классический механизм аутентификации через форму:
   - Добавить endpoint `register` в приложение для регистрации пользователя посредством передачи JSON файла с информацией о пользователе.
- Настроить обработку аутентификации через реализацию `UserDetailsService`:
   - Реализовать метод `loadUserByUsername` для загрузки пользователя из базы данных.
   - Использовать `PasswordEncoder` (например, `BCryptPasswordEncoder`) для сравнения паролей.

### 4. Использовать кэширование для метода `UserService.loadUserByUsername`
- Включить кэширование в приложении:
   - Добавить аннотацию `@EnableCaching` в основной класс Spring Boot.
- Изменить метод `loadUserByUsername` в классе, реализующем `UserDetailsService`, чтобы использовать кэширование (добавить аннотацию)
- Для кэширования обязательно указать название кэша - `UsernameCache` для корректной работы тестов

## Лабораторная работа сдана, если:
1. Все unit-тесты и интеграционные тесты пройдены. Для запуска интеграционных тестов должен быть установлен Docker Desktop (альтернативы).
2. SonarLint в отчёте не выдает code smells (Правая кнопка мыши на проект -> SonarLint -> Analyze with SonarLint -> Proceed). Должен быть в IDEA установлен плагин SonarLint.
3. Приложение не выдает необработанных ошибок.
4. Нет похожего кода у других студентов.

## Процесс выполнения лабораторной работы:
1. Клонируете себе репозиторий лабораторной работы.
2. Создаете от ветки develop ветку с именем student/фамилия_перваябукваимени_lab1. Убедитесь, что не выполняете коммиты и пуши в develop!!!
3. Пишите код.
4. Все переменные окружения в качестве примера берете из config.env
5. Запускаете все тесты, все тесты должны быть пройдены.
6. Исправляете code smells от SonarLint - не должно быть ни одного code smells
7. Когда считаете, что лабораторная работа готова к проверке создаете pull request в ветку release и ставите label
   "Можно проверять лабораторную работу"
8. По pull request происходит проверка кода и оставляются замечания в коде, которые надо поправить, у pull request будет label "Нужны правки"
9. Если лабораторная работа принята, то у pull request будет label "Лабораторная работа зачтена"
10. Для pull request не нажимаем кнопку merge и close после того, как лабораторная работа зачтена!!!
